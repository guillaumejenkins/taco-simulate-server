// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.

var config = require('../config');
var fs = require('fs');
var log = require('../log');
var ncp = require('ncp');
var path = require('path');
var prepare = require('../prepare');
var Q = require('q');

var eventIgnoreDuration = 150;
var wwwRoot = 'www';
var mergesRoot = 'merges';
var unknownFileId = '__sim-unknown__';

function Watcher(cssCb, nonCssCb) {
    this.cssChangedCallback = cssCb;
    this.nonCssChangedCallback = nonCssCb;
    this.ignoreEvents = {};
    this.mergesOverridePath = path.join(config.projectRoot, mergesRoot, config.platform);
    this.mergesOverrideExists = fs.existsSync(this.mergesOverridePath);
}

Watcher.prototype.startWatching = function () {
    this.wwwWatcher = fs.watch(path.join(config.projectRoot, wwwRoot), { recursive: true }, handleWwwWatcherEvent.bind(this));

    if (this.mergesOverrideExists) {
        this.mergesWatcher = fs.watch(path.join(config.projectRoot, mergesRoot, config.platform), { recursive: true }, handleMergesWatcherEvent.bind(this));
    }
};

Watcher.prototype.stopWatching = function () {
    if (this.wwwWatcher) {
        this.wwwWatcher.close();
        this.wwwWatcher = null;
    }

    if (this.mergesWatcher) {
        this.mergesWatcher.close();
        this.mergesWatcher = null;
    }
}

function handleWwwWatcherEvent(event, fileRelativePath) {
    handleWatcherEvent.bind(this)(wwwRoot, fileRelativePath);
}

function handleMergesWatcherEvent(event, fileRelativePath) {
    handleWatcherEvent.bind(this)(mergesRoot, fileRelativePath);
}

function handleWatcherEvent(root, fileRelativePath) {
    // fs.watch() will often send events more than once for the same modification, especially on Windows. A workaround is to block events generated by the same file for a short duration.
    var ignoreId = fileRelativePath || unknownFileId;
    
    if (this.ignoreEvents[ignoreId]) {
        return;
    }

    this.ignoreEvents[ignoreId] = true;
    setTimeout(function () {
        this.ignoreEvents[ignoreId] = false;
    }.bind(this), eventIgnoreDuration);

    if (!fileRelativePath) {
        // fs.watch() doesn't always set the fileRelativePath argument properly. If that happens, let the user know.
        log.warning('Could not reload the modified file because fs.watch() didn\'t specify which file was changed');

        return;
    }

    // Make sure the modified file is either JS, HTML or CSS
    if (!fileIsOfType(fileRelativePath, ['.html', '.css', '.js'])) {
        return;
    }

    // If the modified file is under www/, but has a merges/[platform]/ override, we don't do anything (because the running app is not using the file that was just modified).
    var isWww = root === wwwRoot;

    if (isWww && fileHasMergesOverride.bind(this)(fileRelativePath)) {
        return;
    }

    // Propagate the change to the served platform folder (either via Cordova prepare, or by copying the file directly).
    var preparePromise;
    var isCss = fileIsOfType(fileRelativePath, '.css');

    if (isCss) {
        if (config.prepareOnCssChange) {
            // Sometimes, especially on Windows, prepare will fail because the modified file is locked for a short duration after modification, so we try to prepare twice.
            preparePromise = retryAsync(prepare.execCordovaPrepare, 2);
        } else {
            var srcPathPrefix = isWww ? path.join(config.projectRoot, wwwRoot) : this.mergesOverridePath;
            var srcAbsolutePath = path.join(srcPathPrefix, fileRelativePath);
            var destAbsolutePath = path.join(config.platformRoot, fileRelativePath);

            preparePromise = copyFile(srcAbsolutePath, destAbsolutePath);
        }
    } else {
        // No need to prepare, because the server already does when app-host does a full reload.
        preparePromise = Q.resolve();
    }

    // Invoke the appropriate callback.
    preparePromise.then(function () {
        if (isCss) {
            this.cssChangedCallback(fileRelativePath);
        } else {
            this.nonCssChangedCallback();
        }
    }.bind(this)).done();
}

function fileIsOfType(fileRelativePath, ext) {
    var fileExt = path.extname(fileRelativePath).toLowerCase()

    function checkType(t) {
        return fileExt === t.toLowerCase();
    }

    if (Array.isArray(ext)) {
        return ext.reduce(function (isOfTypeSoFar, currentTypeToCheck) {
            return isOfTypeSoFar || checkType(currentTypeToCheck);
        }, false);
    }

    return checkType(ext);
}

function fileHasMergesOverride(fileRelativePath) {
    return this.mergesOverrideExists && fs.existsSync(path.join(this.mergesOverridePath, fileRelativePath));
}

function copyFile(src, dest) {
    return Q.nfcall(ncp, src, dest);
}

function retryAsync(promiseFunc, maxTries, delay, iteration) {
    delay = typeof delay === 'undefined' ? 100 : delay;
    iteration = typeof iteration === 'undefined' ? 1 : iteration;

    return promiseFunc().catch(function (err) {
        if (iteration < maxTries) {
            return Q.delay(delay).then(function () {
                return retryAsync(promiseFunc, maxTries, delay, iteration + 1);
            });
        }

        return Q.reject(err);
    });
}

exports.Watcher = Watcher;